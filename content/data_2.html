<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>My Hitchhiker Guide to AI – data_2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../images/favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-center sidebar-header">
      <a href="../index.html" class="sidebar-logo-link">
      <img src="https://img.freepik.com/premium-vector/artificial-intelligence-logo-icon-vector-symbol-ai-deep-learning-blockchain-neural-network-concept-machine-learning-artificial-intelligence-ai_230610-480.jpg" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
      <div class="sidebar-tools-main tools-wide">
    <a href="https://knabenphysik.github.io/ai_note" rel="" title="Open Data Science" class="quarto-navigation-tool px-1" aria-label="Open Data Science"><i class="bi bi-globe"></i></a>
    <a href="https://github.com/knabenphysik/ai_note" rel="" title="AI Note" class="quarto-navigation-tool px-1" aria-label="AI Note"><i class="bi bi-github"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Home</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/intro-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Basic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About Data</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/learning_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About Learning I</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/learning_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About Learning II</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/learning_3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About Learning III</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/use_case.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Type of Learning</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#data-and-sampling" id="toc-data-and-sampling" class="nav-link active" data-scroll-target="#data-and-sampling">Data and sampling</a>
  <ul class="collapse">
  <li><a href="#methods-of-data-transformation" id="toc-methods-of-data-transformation" class="nav-link" data-scroll-target="#methods-of-data-transformation">Methods of data transformation</a></li>
  <li><a href="#sampling-and-validation" id="toc-sampling-and-validation" class="nav-link" data-scroll-target="#sampling-and-validation">Sampling and validation</a></li>
  <li><a href="#predictive-modelling" id="toc-predictive-modelling" class="nav-link" data-scroll-target="#predictive-modelling">Predictive modelling</a>
  <ul class="collapse">
  <li><a href="#types-of-learning" id="toc-types-of-learning" class="nav-link" data-scroll-target="#types-of-learning">Types of learning</a></li>
  <li><a href="#interpretability-vs-flexibility" id="toc-interpretability-vs-flexibility" class="nav-link" data-scroll-target="#interpretability-vs-flexibility">Interpretability vs flexibility</a></li>
  </ul></li>
  </ul></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/knabenphysik/ai_note/edit/main/content/data_2.qmd" class="toc-action">Edit this page</a></p><p><a href="https://github.com/knabenphysik/ai_note/blob/main/content/data_2.qmd" class="toc-action">View source</a></p><p><a href="https://github.com/knabenphysik/ai_note/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">



<section id="data-and-sampling" class="level1">
<h1>Data and sampling</h1>
<p>First we must differentiate between <strong>data at hand</strong> - which is the data that is available to us as modeller, and <strong>data not in hand</strong>, which are data not yet available or will come in the future whereby the model will be applied on. True reliability of the model will be when tested against data not in hand. To understand this, we need to go back to “estimator errors” and “estimator bias” that we discuss before.</p>
<p>Second, we have to be cognizant of the sample size of the data at hand. We always prefer <strong>large amount</strong> of data, but how large is large, and how big is big? This is a problem of <strong>sufficiency</strong>, because even though the data may be large, but contains insufficient <strong>entropy</strong>, will render the data to be small, despite the large size in bytes. Size and entropy matters because Law of Large Numbers hypothesis rely heavily on it. If the size is not too large and yet have high enough entropy, the hypothesis is tested with high power (low <span class="math inline">\(\beta\)</span>, Type II error); and yet large size with low entropy will reduce Type I error (Low <span class="math inline">\(\alpha\)</span>, increase True Negative).</p>
<p>Third, we must take note of problems within the data itself, namely the “true process” of data generations. This is at best is unknown - but is assumed to follow stable process which are Gaussian, ergodic, and stationary in nature. This is far from true in many real applications. If we go back to earlier discussions, this is included under the “pure errors” part of the estimation process. The key assumption that we made is that <strong>residual errors</strong> (“pure errors”,“white noise”) follows an IID process (Independent and Identically Distributed). This is a strong assumption which to most modellers, they just assumed that it holds all the time. We know from practice that this IID assumption fails and fail miserably at time.</p>
<p><strong>Data transformation</strong></p>
<p>Many times in ML we have to pre-process the data by “normalizing”, such as to set it to be in [0,1] (by scaling), or [-1,+1], scaling and centering, log or exponential, square root, etc. All these exercises do is only changing the scale and not the structure of the data. This is needed to assist computations and reduce computing errors, and not in any way doing anything beyond that.</p>
<p><strong>Data augmentation</strong></p>
<p>Data augmentation is used when we want to add “organized entropy” into an existing data set. This is only meaningful if those entropy helps to expand the data at hand, without altering the “meaninful aspects” of the data. That’s why it is useful in image processing or voice, which structures are not altered, but increase the space and dimensions.</p>
<p><strong>Data de-noising</strong></p>
<p>Opposite to augmentation is “de-noising”, where we apply filters to take out the noises in the data. The argument here is reverse that is to reduce entropy in the data. Again, this is meaningful if there are no alterations to the basic structure of the data; and hence useful in image or voice processing. In NLP, removal of stop-words is a de-noising exercise.</p>
<p><strong>Data pre-processing</strong></p>
<p>Data pre-processing may involve all of the above: transformation, augmentation and de-noising. In some cases all are required and helpful, in some cases a mixture of them will do. The basic process however is always data transformation.</p>
<section id="methods-of-data-transformation" class="level3">
<h3 class="anchored" data-anchor-id="methods-of-data-transformation">Methods of data transformation</h3>
<ol type="1">
<li>Scaling</li>
</ol>
<p>Scaling and centering (if needed) is the most basic method. Why its needed (beside computing reasons)? To enable interpretations of the model to be easier, because most of the cases we are dealing with probabilities, which is a number in [0,1]. Furthermore, this will standardied numbers of various scales into same unique scale.</p>
<ol start="2" type="1">
<li>Log transformation</li>
</ol>
<p>Logarithmic function acts both as dampener and smoother. However, log has one major problem: log(0) is undefined. So we must deal with numbers which are strictly positive, such as (0,1]. Log transformation is generally very useful, especially for highly skewed data.</p>
<ol start="3" type="1">
<li>Vectorization</li>
</ol>
<p>Vectorization is a method of mapping a set of data onto a smaller space, represented by unique mapping between the raw data and a vector space, which serves as a “look-up table”. Vectorizing does not alter the structure of the data, instead it just compressed the data into a smaller space in terms of computer memories. Instead of working with raw data, we deal with its vectorize representations. An example of this hashing algorithms, which converts any non-fixed size elements onto unique fixed size space. Tokenization is another used method for vectorization in NLP.</p>
<ol start="4" type="1">
<li>Binning and encoding</li>
</ol>
<p>Binning is used when we want to convert continous variables to categorical variables. There are few methods used:</p>
<ol type="a">
<li>Equal width binning - what is normally used in general</li>
<li>Frequence width binning - grouped by largest frequencies instead of equal width</li>
<li>Entropy based binning - retaining the largest amount of information regarding the ranks of the data by discretizing into a uniform distribution.</li>
</ol>
<p>Encoding is the opposite of binning, where we convert categorical variables to continous variables. There are a few methods used:</p>
<ol type="a">
<li>Label encoding</li>
<li>Binary encoding</li>
<li>Ordinal encoding</li>
<li>One hot encoding</li>
<li>Frequency encoding</li>
<li>Target mean encoding</li>
</ol>
<ol start="5" type="1">
<li>Power transformer</li>
</ol>
<p>Power transformation is used to transform non-Gaussian type distribution (such as many outliers or highly skewed) to have more of Gaussian type distribution; there are two popular methods used:</p>
<ul>
<li>Box-Cox transformation - values must be strictly positive</li>
<li>Yeo-Johnson transformer - values can be negative</li>
</ul>
<ol start="6" type="1">
<li>Missing values imputation</li>
</ol>
<p>There are a number of methods:</p>
<ol type="a">
<li>mean, median, etc., basic statistical method</li>
<li>k-NN</li>
<li>MLP</li>
<li>Self-organization Map (SOM)</li>
</ol>
<ol start="7" type="1">
<li>Dimensionality reduction</li>
</ol>
<p>The more complex part of data pre-processing is <strong>dimensionality reduction</strong>. This is a non-trivial process. Mathematically, this is a “map-reduce” process; where anywhere possible, set of variables are mapped together into a variable which becomes a representative of the set, and this is performed over various possible distinct sets, and the final output will be represented by these representative variables, which will be supplied to the model.</p>
<ol start="8" type="1">
<li>Changing data types</li>
</ol>
<p>From integer to factor, factor to integer, numerical to categorical, ordinal to categorical, etc.</p>
<ol start="9" type="1">
<li>Multilabels hierarchical data</li>
</ol>
<p>Another approach is called “Multi hierarchical labels”</p>
</section>
<section id="sampling-and-validation" class="level3">
<h3 class="anchored" data-anchor-id="sampling-and-validation">Sampling and validation</h3>
<p>Sometimes this is called “Model Tuning” to overcome “over-fitting”.</p>
<p>The steps are:</p>
<ol type="1">
<li>Start with a randomized sample - fit the model - predict on hold out sample</li>
<li>Resample and repeat step 1</li>
<li>Profile all the sample and resample into a performance profile</li>
<li>Decide the final tuning parameters</li>
<li>Refit the model using the entire dataset</li>
</ol>
<p>Managing data splitting to accomodate for:</p>
<ol type="1">
<li>Pre-processing the predictor data (Xs)</li>
<li>Estimating model parameters (MSE etc)</li>
<li>Select predictors (subset of Xs)</li>
<li>Evaluate model performance</li>
<li>Fine tuning using ROC curves etc.</li>
</ol>
<p>Resampling techniques:</p>
<ol type="1">
<li>General cross validation: set the training versus validation set, and finally testing set.</li>
<li>k-fold cross validation: partition the data to k equal size. Model is fit using all except first subset (first fold), return the first subset to the data and hold out second set, repeat, and so on.</li>
<li>Repeated CV : apply method 1 but keep randomizing the sets.</li>
<li>Bootstrap : sampling data with replacement by dividing into “in the bag” and “out of bag” samples.</li>
</ol>
</section>
<section id="predictive-modelling" class="level2">
<h2 class="anchored" data-anchor-id="predictive-modelling">Predictive modelling</h2>
<section id="types-of-learning" class="level3">
<h3 class="anchored" data-anchor-id="types-of-learning">Types of learning</h3>
<ol type="1">
<li>Association, that is <span class="math inline">\(Pr(Y|X)\)</span></li>
<li>Classification, that is <span class="math inline">\(if(x_1 &gt; a)\)</span> and <span class="math inline">\(if(x_2 &lt; b)\)</span> then ..</li>
<li>Pattern recognition
<ul>
<li>Pixel based (image and video)</li>
<li>word based (NLP)</li>
<li>frequency based (sound, etc.)</li>
</ul></li>
<li>Knowledge extraction
<ul>
<li>emergent structures</li>
<li>extreme observations (outlier) detection</li>
</ul></li>
<li>Reinforcement learning
<ul>
<li>Game theoretic</li>
<li>Probabilistic learning</li>
</ul></li>
<li>Network or Graph theory based learning
<ul>
<li>Driven by network/graph theory</li>
<li>Emergent</li>
<li>Scaling</li>
</ul></li>
</ol>
</section>
<section id="interpretability-vs-flexibility" class="level3">
<h3 class="anchored" data-anchor-id="interpretability-vs-flexibility">Interpretability vs flexibility</h3>
<p>It is important to know the objective; this will determine which is more important in choosing models and methods</p>
<p>Classically in statistics - this is called the “degrees of freedom” of any statistical tests and estimators.</p>
<p>Trade-offs between interpretability and flexibility is a major issue.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">Draft,© <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.en">CC BY-SA</a></div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">Built with <a href="https://quarto.org/">Quarto</a>.</div>
  </div>
</footer>



</body></html>